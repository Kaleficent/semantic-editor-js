<!--

next up:

add a debug tree to show the model

move all model manipulation code to separate module. start using browserify
model nodes have ref to parent. should simplify model manipulation code
model has function to change style on a node
model has function to load a new model
model has function to fetch model as JSON

util function for deleting children from a DOM node

make a wrapper function which saves selection, executes action, syncs the dom, then updates selection again

handle the case where you delete a selection across block boundaries
special case enter key inside of a code block
special case tab key inside of code block: indent/outdent

make prettier styles
add semantic type style using after:content: css

redo demo layout with proper scrolling, flexbox, etc.

remove duplicate change events. should just be add, delete, and text


abstract keyboard handling into a separate class.
attach commands to keystrokes with a map

implement making a link with command-shift-A
invokes a callback to open a dialog and set the result.

implement list support
    switch block type to list item
    enter to make next list item
    switch from numbered to bulleted items
    indent/outdent

implement a model extension for images and other embedded media. forms, etc.


more content types:
blockquote
several header levels: title, subtitle, section


-->


<html>
<head>
<style type='text/css'>
.bold {
    color: red;
    font-weight: bold;
}
.italic {
    color: green;
    font-weight: normal;
    font-style: italic;
}
.inline-code {
    font-weight: normal;
    color: #cccc00;
    font-family: monospace;
}
.block-code {
    color: #cccc00;
    font-family: monospace;
    border: 1px solid yellow;
    padding: 0.5em;
    white-space: pre;

}
.body {
    color: darkgray;
    border: 1px solid #ccc;
}

#editor {
    border: 1px solid grey;
    padding: 0.5em;
}
.header {
    font-size: 150%;
    background-color: #ffcccc;
}

div {
    border: 1px solid blue;
    margin: 1em;
    padding: 1em;
}
</style>

</head>
<body>
    <div id="editor" contenteditable="true" spellcheck="false"></div>
    <div>
        <button id="header">header</button>
        <button id="body">body</button>
        <button id="block-code">code block</button>
    </div>
    <div id="debug-tree"></div>
</body>
<script src="bundle.js"></script>
<script type='text/javascript'>

var model = require('model');
model.check();

var count = 0;
function genId() {
    count++;
    return "id_"+count;
}

var model = [
{
    id:genId(),
    type:'block',
    style:'body',
    content:[
        {
            id:genId(),
            type:'text',
            content:'this is a header'
        }
    ]
},

{
    id:genId(),
    type:'block',
    style:'body',
    content: [
        {
            id:genId(),
            type:'text',
            content:'more body text'
        }
    ]
},

{
    id:genId(),
    type:'block',
    style:'body',
    content: [
        {
            id:genId(),
            type:'text',
            content:'This is some '
        },
        {
            id:genId(),
            type:'inline',
            style:'bold',
            content:[
                {
                    id:genId(),
                    type:'text',
                    content:'bold'
                }
            ]
        },
        {
            id:genId(),
            type:'text',
            content:' text to read'
        }
    ]
},
{
    id:genId(),
    type:'block',
    style:'block-code',
    content:[
        {
            type:'text',
            content:'for(var i=0; i<5; i++){\n    console.log("line",i);\n}'
        }
    ]
}
];

var editor = document.getElementById('editor');
function syncDom(editor,model) {
    renderTree();
    while (editor.firstChild) {
        editor.removeChild(editor.firstChild);
    }
    model.forEach(function (block) {
        var blockElement = document.createElement('div');
        blockElement.id = block.id;
        blockElement.classList.add(block.style);
        block.content.forEach(function (inline) {
            if (inline.type == 'text') {
                blockElement.appendChild(document.createTextNode(inline.content));
            }
            if (inline.type == 'inline') {
                var elem = document.createElement('span');
                elem.id = inline.id;
                elem.classList.add(inline.style);
                elem.appendChild(document.createTextNode(inline.content[0].content));
                blockElement.appendChild(elem);
            }
        });
        editor.appendChild(blockElement);
    });
}

syncDom(editor,model);

function renderTree() {
}
function saveSelection(ed) {
    var sel = window.getSelection();
    var range = sel.getRangeAt(0);
    var node = range.startContainer;
    var path = [];
    while(node.nodeType == Element.TEXT_NODE || node.id == "") {
        var nn = -1;
        for(var i=0; i<node.parentNode.childNodes.length; i++) {
            if(node.parentNode.childNodes[i] == node) {
                nn = i;
            }
        }
        path.unshift(nn);
        node = node.parentNode;
    }
    return {
        id:node.id,
        path:path,
        startOffset:range.startOffset,
        endOffset:range.endOffset
    };
}

function restoreSelection(ran) {
    if(ran.id == "") {
        console.log("WARNING. bad id");
        return;
    }
    var range = document.createRange();
    var node = document.getElementById(ran.id);
    ran.path.forEach(function(index){
        node = node.childNodes[index];
    });
    range.setStart(node, ran.startOffset);
    range.collapse(true);
    var wsel = window.getSelection();
    wsel.removeAllRanges();
    wsel.addRange(range);
}

function genModelFromDom(node) {
    if(node.nodeType == Element.TEXT_NODE) {
        return {
            id:genId(),
            type:'text',
            content: node.nodeValue
        }
    }
    if(node.nodeType == Element.ELEMENT_NODE) {
        var content = [];
        for(var i=0; i<node.childNodes.length; i++) {
            content.push(genModelFromDom(node.childNodes[i]));
        }
        var style = 'bold';
        var type = 'inline';
        if(Array.prototype.indexOf.call(node.classList,'italic') >= 0) {
            type = 'inline';
            style = 'italic';
        }
        if(Array.prototype.indexOf.call(node.classList,'header') >= 0) {
            style = 'header';
            type = 'block';
        }
        return {
            id:genId(),
            type:type,
            style:style,
            content:content
        }
    }
    console.log("ERROR. UNSUPPORTED NODE TYPE",node.nodeType,node);
}

function applyChanges(editor,model,changes) {
    changes.forEach(function(ch){
        if(ch.type=='text') {
            ch.model_node.content = ch.new_text;
        }
        if(ch.type == 'append') {
            if(ch.dom_node.nodeType == Element.ELEMENT_NODE) {
                ch.model.push(genModelFromDom(ch.dom_node));
            }
            if(ch.dom_node.nodeType == Element.TEXT_NODE) {
                ch.model.push(genModelFromDom(ch.dom_node));
            }
        }
        if(ch.type == 'remove'){
            ch.model.splice(ch.mod_i,1);
        }
        if(ch.type == 'delete'){
            ch.model.splice(ch.mod_i,1);
        }
        if(ch.type == 'insert') {
            var mod = genModelFromDom(ch.dom_node);
            ch.model.splice(ch.mod_i,0,mod);
        }
    });
}

function scanForChanges(root,model) {
    var changes = [];
    if(root.childNodes.length != model.length) {
        console.log("WARNING: length has changed");
    }
    /*
    for(var i=0; i<root.childNodes.length; i++) {
        console.log("dom id", root.childNodes[i].id);
    }
    for(var i=0; i<model.length; i++) {
        console.log("mod id", model[i].id);
    }
    */
    var dom_i = 0;
    var dom_len = root.childNodes.length;
    var mod_i = 0;
    var mod_len = model.length;
    var prev_dom = null;
    while(true) {
        if(mod_i >= mod_len || dom_i >= dom_len) {
            if(dom_i < dom_len) {
                console.log("still more dom. must have added",dom_i,dom_len);
                for(;dom_i<dom_len; dom_i++) {
                    changes.push({
                        type:'append',
                        model:model,
                        dom_node:root.childNodes[dom_i]
                    });
                }
            }
            if(mod_i < mod_len) {
                console.log("still more model. must have deleted",mod_i,mod_len);
                for(;mod_i<mod_len;mod_i++) {
                    changes.push({
                        type:'remove',
                        model:model,
                        mod_i:mod_i
                    });
                }
            }
            break;
        }

        var dom_node = root.childNodes[dom_i];
        var mod_node = model[mod_i];
        if(mod_node.type == 'text' && dom_node.nodeType == Element.TEXT_NODE) {
//            console.log("it a text node");
            var dom_text = dom_node.nodeValue;
            var model_text = mod_node.content;
            if(dom_text != model_text) {
//                console.log("text has changed",model_text,'->',dom_text);
                changes.push({
                    type:'text',
                    old_text:model_text,
                    new_text:dom_text,
                    model_node:mod_node,
                    dom_node:dom_node
                });
            }
        }
        if(mod_node.type == 'block') {
            if(dom_node.id != mod_node.id) {
                if(prev_dom != null && dom_node.id == prev_dom.id) {
                    changes.push({
                        type:'insert',
                        mod_i:mod_i,
                        model:model,
                        dom_node:dom_node
                    });
                    dom_i++;
                }
                var next_mod = null;
                if(mod_i+1 < mod_len ) {
                    next_mod = model[mod_i+1];
                }
                if(next_mod != null && dom_node.id == next_mod.id) {
                    changes.push({
                        type:'delete',
                        model:model,
                        mod_i:mod_i
                    });
                    mod_i++;
                }
            } else {
                changes = changes.concat(scanForChanges(dom_node, mod_node.content));
            }
        }
        if(mod_node.type == 'inline') {
            changes = changes.concat(scanForChanges(dom_node,mod_node.content));
        }
        dom_i++;
        prev_dom = dom_node;
        mod_i++;
    };
    return changes;
}

function selectionToModelNode(info,model) {
    for(var i=0; i<model.length; i++) {
        var node = model[i];
        if(node.id == info.id) {
            info.path.forEach(function(index) {
                node = node.content[index];
            });
            return node;
        }
    }
    return null;
}

//TODO: this function is a hack. should be replaced by just giving children refs to parent
function findParentOfModelNode(root,target) {
    for(var i=0; i<root.content.length; i++) {
        var node = root.content[i];
        if(node.id == target.id) {
            return root;
        }
        if(node.type == 'block' || node.type == 'inline') {
            var ans = findParentOfModelNode(node,target);
            if(ans != null) return ans;
        }
    }
    return null;
}

//TODO: this function is a hack. should be replaced by just giving children refs to parent
function findIndexOfChild(parent,child) {
    var n = 0;
    for(var i=0; i<parent.content.length; i++) {
        if(parent.content[i] == child) return i;
    }
    return -1;
}

//replaces the first node in it's parent with the rest of the nodes
function swapNode() {
    var args = Array.prototype.slice.call(arguments);
    var oldnode = args.shift();
    var rest = args;
    var parent = findParentOfModelNode({content:model},oldnode);
    var index = findIndexOfChild(parent,oldnode);
    var cargs = [index,1].concat(rest);
    parent.content.splice.apply(parent.content,cargs);
}

//splits a text node in half at the requested offset
function splitModelNode(n,mod) {
    if(mod.type != 'text') {
        console.log("ERROR: don't know how to split non text node yet");
        return;
    }
    var a = {
        type:mod.type,
        id:genId(),
        content:mod.content.substring(0,n)
    };
    var b = {
        type:mod.type,
        id:genId(),
        content:mod.content.substring(n)
    };

    swapNode(mod,a,b);
    return [a,b];
}

function wrapTextInInlineStyle(node,style) {
    var inline = {
        id:genId(),
        type:'inline',
        style:style,
        content: [ {
            id:genId(),
            type:'text',
            content:node.content
        } ]
    };
    swapNode(node,inline);
}

function splitThree(node,index1,index2) {
    var parts1 = splitModelNode(index1,node);
    var parts2 = splitModelNode(index2-index1,parts1[1]);
    return [parts1[0],parts2[0],parts2[1]];
}

function styleSelectionInline(style) {
    var sel = window.getSelection();
    var range = sel.getRangeAt(0);
    if(range.collapsed) {
        console.log("just change the state");
        return;
    }
    var info = saveSelection(editor);
    var mod = selectionToModelNode(info,model);
    var parts = splitThree(mod,info.startOffset,info.endOffset)
    wrapTextInInlineStyle(parts[1],style);
    syncDom(editor,model);
    restoreSelection(info);
}

function stopEvent(e) {
    e.preventDefault();
    e.stopPropagation();
}

function findParentBlockDom(elem) {
    var parent = elem.parentElement;
    if(parent.tagName == 'DIV') {
        return parent;
    }
    return null;
}

function findModelForDom(root,target) {
    for(var i=0; i<root.content.length; i++) {
        var node = root.content[i];
        if(node.id == target.id) {
            return node;
        }
        if(node.type == 'block' || node.type == 'inline') {
            var ans = findModelForDom(node,target);
            if(ans != null) return ans;
        }
    }
    return null;
}

function changeBlockStyle(style) {
    var sel = window.getSelection();
    var range = sel.getRangeAt(0);
    var block = findParentBlockDom(range.commonAncestorContainer);
    var mod_b = findModelForDom({content:model},block);
    mod_b.style = style;
    var ran = saveSelection(editor);
    syncDom(editor,model);
    restoreSelection(ran);
}

document.getElementById("editor").addEventListener("input", function(e) {
    console.log("INPUT EVENT");
    var sel = saveSelection(editor);
    var changes = scanForChanges(editor,model);
    applyChanges(editor,model,changes);
    syncDom(editor,model);
    restoreSelection(sel);
}, false);

document.getElementById('editor').addEventListener('keydown',function(e){
    if(e.metaKey===true && e.keyCode == 66) { //cmd-B
        stopEvent(e);
        styleSelectionInline('bold');
    }
    if(e.metaKey===true && e.keyCode == 73) { //cmd-I
        stopEvent(e);
        styleSelectionInline('italic');
    }
    if(e.metaKey===true && e.keyCode == 67 && e.shiftKey) { //cmd-shift-C
        stopEvent(e);
        styleSelectionInline('inline-code');
    }
});

document.getElementById("header").addEventListener('click',function(e) {
    stopEvent(e);
    changeBlockStyle('header');
});
document.getElementById("body").addEventListener('click',function(e) {
    stopEvent(e);
    changeBlockStyle('body');
});
document.getElementById("block-code").addEventListener('click',function(e) {
    stopEvent(e);
    changeBlockStyle('block-code');
});
</script>
</html>
