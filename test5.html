<!--

in this one we will sync a model to the dom and back.
then we can do all modifications on the model and know it works right.
we have to detect dom changes using mutation observers
-->


<html>
<head>
<style type='text/css'>
.bold {
    color: red;
    font-weight: bold;
}
.italic {
    color: green;
    font-weight: normal;
    font-style: italic;
}
.inline-code {
    font-weight: normal;
    color: #cccc00;
    font-family: monospace;
}
.block-code {
    color: #cccc00;
    font-family: monospace;
    border: 1px solid yellow;
    padding: 0.5em;
    white-space: pre;

}
.body {
    color: darkgray;
    border: 1px solid #ccc;
}

#editor {
    border: 1px solid grey;
    padding: 0.5em;
}
.header {
    font-size: 150%;
    background-color: #ffcccc;
}

div {
    border: 1px solid blue;
    margin: 1em;
    padding: 1em;
}
</style>

</head>
<body>
    <div id="editor" contenteditable="true" spellcheck="false"></div>
    <div>
        <button id="header">header</button>
        <button id="body">body</button>
        <button id="block-code">code block</button>
    </div>
</body>
<script type='text/javascript'>

var count = 0;
function genId() {
    count++;
    return "id_"+count;
}

var model = [
{
    id:genId(),
    type:'block',
    style:'body',
    content:[
        {
            id:genId(),
            type:'text',
            content:'this is a header'
        }
    ]
},
/*
    {
        id:genId(),
        type:'block',
        style:'body',
        content: [
            {
                id:genId(),
                type:'text',
                content:'more'
            }
        ]
    }
    */
/*{
    id:genId(),
    type:'block',
    style:'body',
    content: [
        {
            id:genId(),
            type:'text',
            content:'This is some '
        },
        {
            id:genId(),
            type:'inline',
            style:'bold',
            content:[
                {
                    id:genId(),
                    type:'text',
                    content:'bold'
                }
            ]
        },
        {
            id:genId(),
            type:'text',
            content:' text to read'
        }
    ]
},
{
    id:genId(),
    type:'block',
    style:'block-code',
    content:[
        {
            type:'text',
            content:'for(var i=0; i<5; i++){\n    console.log("line",i);\n}'
        }
    ]
}*/
];

var editor = document.getElementById('editor');
function syncDom(editor,model) {
    while (editor.firstChild) {
        editor.removeChild(editor.firstChild);
    }
    model.forEach(function (block) {
        var blockElement = document.createElement('div');
        blockElement.id = block.id;
        blockElement.classList.add(block.style);
        block.content.forEach(function (inline) {
            if (inline.type == 'text') {
                blockElement.appendChild(document.createTextNode(inline.content));
            }
            if (inline.type == 'inline') {
                var elem = document.createElement('span');
                elem.id = inline.id;
                elem.classList.add(inline.style);
                elem.appendChild(document.createTextNode(inline.content[0].content));
                blockElement.appendChild(elem);
            }
        });
        editor.appendChild(blockElement);
    });
}

syncDom(editor,model);

function saveSelection(ed) {
    var sel = window.getSelection();
//    console.log("saving selection",sel);
    var range = sel.getRangeAt(0);
//    console.log("range = ", range);
    var node = range.startContainer;
    var path = [];
    while(node.nodeType == Element.TEXT_NODE || node.id == "") {
//        console.log("no node of it's own. moving up");
        var nn = -1;
        for(var i=0; i<node.parentNode.childNodes.length; i++) {
            if(node.parentNode.childNodes[i] == node) {
                nn = i;
            }
        }
//        console.log("index = ",nn);
        path.unshift(nn);
        node = node.parentNode;
    }
//    console.log("saving with node:",node.id,':');
    return {
        id:node.id,
        path:path,
        startOffset:range.startOffset,
        endOffset:range.endOffset
    };
}

function restoreSelection(ran) {
//    console.log("restoring selection",ran);
    if(ran.id == "") {
        console.log("WARNING. bad id");
        return;
    }
    var range = document.createRange();
    var node = document.getElementById(ran.id);
    ran.path.forEach(function(index){
//        console.log("checking index",index);
        node = node.childNodes[index];
//        console.log("next ch = ", node);
    });
    range.setStart(node, ran.startOffset);
    range.collapse(true);
    var wsel = window.getSelection();
    wsel.removeAllRanges();
    wsel.addRange(range);
}

document.getElementById("editor").addEventListener("input", function(e) {
    console.log("INPUT EVENT");
    var sel = saveSelection(editor);
    var changes = scanForChanges(editor,model);
    applyChanges(editor,model,changes);
    syncDom(editor,model);
    restoreSelection(sel);
}, false);

function genModelFromDom(node) {
    if(node.nodeType == Element.TEXT_NODE) {
        return {
            id:genId(),
            type:'text',
            content: node.nodeValue
        }
    }
    if(node.nodeType == Element.ELEMENT_NODE) {
        var content = [];
        for(var i=0; i<node.childNodes.length; i++) {
            content.push(genModelFromDom(node.childNodes[i]));
        }
        var style = 'bold';
        var type = 'inline';
        if(Array.prototype.indexOf.call(node.classList,'italic') >= 0) {
            type = 'inline';
            style = 'italic';
        }
        if(Array.prototype.indexOf.call(node.classList,'header') >= 0) {
            style = 'header';
            type = 'block';
        }
        return {
            id:genId(),
            type:type,
            style:style,
            content:content
        }
    }
    console.log("ERROR. UNSUPPORTED NODE TYPE",node.nodeType,node);
}

function applyChanges(editor,model,changes) {
    console.log('change count',changes.length);
    changes.forEach(function(ch){
        console.log("change = ", ch);
        if(ch.type=='text') {
            ch.model_node.content = ch.new_text;
        }
        if(ch.type == 'append') {
            console.log("applying an append",ch);
            if(ch.dom_node.nodeType == Element.ELEMENT_NODE) {
                console.log("adding an element");
                ch.model.push(genModelFromDom(ch.dom_node));
            }
            if(ch.dom_node.nodeType == Element.TEXT_NODE) {
                console.log("adding a text node");
                ch.model.push(genModelFromDom(ch.dom_node));
            }
        }
        if(ch.type == 'remove'){
            console.log("applying a remove",ch.mod_i,ch.model.length);
            ch.model.splice(ch.mod_i,1);
        }
        if(ch.type == 'delete'){
            console.log("applying a remove",ch.mod_i,ch.model.length);
            ch.model.splice(ch.mod_i,1);
        }
        if(ch.type == 'insert') {
            console.log("applying an insert");
            var mod = genModelFromDom(ch.dom_node);
            console.log("inserting new model chunk",mod);
            ch.model.splice(ch.mod_i,0,mod);
        }
    });
}

function scanForChanges(root,model) {
    var changes = [];
    if(root.childNodes.length != model.length) {
        console.log("WARNING: length has changed");
    }
    for(var i=0; i<root.childNodes.length; i++) {
        console.log("dom id", root.childNodes[i].id);
    }
    for(var i=0; i<model.length; i++) {
        console.log("mod id", model[i].id);
    }
    var dom_i = 0;
    var dom_len = root.childNodes.length;
    var mod_i = 0;
    var mod_len = model.length;
    var prev_dom = null;
    while(true) {
        if(mod_i >= mod_len || dom_i >= dom_len) {
            console.log("end of the list");
            if(dom_i < dom_len) {
                console.log("still more dom. must have added",dom_i,dom_len);
                for(;dom_i<dom_len; dom_i++) {
                    console.log("adding");
                    changes.push({
                        type:'append',
                        model:model,
                        dom_node:root.childNodes[dom_i]
                    });
                }
            }
            if(mod_i < mod_len) {
                console.log("still more model. must have deleted",mod_i,mod_len);
                for(;mod_i<mod_len;mod_i++) {
                    console.log("removing");
                    changes.push({
                        type:'remove',
                        model:model,
                        mod_i:mod_i
                    });
                }
            }
            break;
        }

        var dom_node = root.childNodes[dom_i];
        var mod_node = model[mod_i];
        if(mod_node.type == 'text' && dom_node.nodeType == Element.TEXT_NODE) {
//            console.log("it a text node");
            var dom_text = dom_node.nodeValue;
            var model_text = mod_node.content;
            if(dom_text != model_text) {
//                console.log("text has changed",model_text,'->',dom_text);
                changes.push({
                    type:'text',
                    old_text:model_text,
                    new_text:dom_text,
                    model_node:mod_node,
                    dom_node:dom_node
                });
            }
        }
        if(mod_node.type == 'block') {
            if(dom_node.id != mod_node.id) {
                console.log("nodes don't match",mod_node.id,dom_node.id);
                if(prev_dom != null && dom_node.id == prev_dom.id) {
                    console.log('this block was just split from the previous. must re-id it',dom_node.id);
                    changes.push({
                        type:'insert',
                        mod_i:mod_i,
                        model:model,
                        dom_node:dom_node
                    });
                    dom_i++;
                }
                var next_mod = null;
                if(mod_i+1 < mod_len ) {
                    next_mod = model[mod_i+1];
                }
                if(next_mod != null && dom_node.id == next_mod.id) {
                    console.log("deleted a dom node");
                    changes.push({
                        type:'delete',
                        model:model,
                        mod_i:mod_i
                    });
                    mod_i++;
                }
            } else {
                console.log("normal recurse",mod_node.id);
                changes = changes.concat(scanForChanges(dom_node, mod_node.content));
            }
        }
        if(mod_node.type == 'inline') {
            changes = changes.concat(scanForChanges(dom_node,mod_node.content));
        }
        dom_i++;
        prev_dom = dom_node;
        mod_i++;
    };
    return changes;
}

function selectionToModelNode(info,model) {
    for(var i=0; i<model.length; i++) {
        var node = model[i];
        if(node.id == info.id) {
            info.path.forEach(function(index) {
                node = node.content[index];
            });
            return node;
        }
    }
    return null;
}

//TODO: this function is a hack. should be replaced by just giving children refs to parent
function findParentOfModelNode(root,target) {
//    console.log("looking for the parent of",target,root.length);
    for(var i=0; i<root.content.length; i++) {
        var node = root.content[i];
//        console.log('chekcing',node.id);
        if(node.id == target.id) {
//            console.log("found the match");
            return root;
        }
        if(node.type == 'block' || node.type == 'inline') {
            var ans = findParentOfModelNode(node,target);
            if(ans != null) return ans;
        }
    }
    return null;
}

//TODO: this function is a hack. should be replaced by just giving children refs to parent
function findIndexOfChild(parent,child) {
    var n = 0;
    for(var i=0; i<parent.content.length; i++) {
//        console.log('checking ',parent.content[i],child);
        if(parent.content[i] == child) return i;
    }
    return -1;
}

//replaces the first node in it's parent with the rest of the nodes
function swapNode() {
    var args = Array.prototype.slice.call(arguments);
    var oldnode = args.shift();
    var rest = args;
    var parent = findParentOfModelNode({content:model},oldnode);
    var index = findIndexOfChild(parent,oldnode);
    var cargs = [index,1].concat(rest);
    parent.content.splice.apply(parent.content,cargs);
}

function splitModelNode(n,mod) {
    //console.log("splitting the model",mod,'at',n);
    if(mod.type != 'text') {
        console.log("ERROR: don't know how to split non text node yet");
        return;
    }
    var a = {
        type:mod.type,
        id:genId(),
        content:mod.content.substring(0,n)
    };
    var b = {
        type:mod.type,
        id:genId(),
        content:mod.content.substring(n)
    };

    swapNode(mod,a,b);
    return [a,b];
}

function wrapTextInInlineStyle(node,style) {
    var inline = {
        id:genId(),
        type:'inline',
        style:style,
        content: [ {
            id:genId(),
            type:'text',
            content:node.content
        } ]
    };
    swapNode(node,inline);
}

function splitThree(node,index1,index2) {
    var parts1 = splitModelNode(index1,node);
    var parts2 = splitModelNode(index2-index1,parts1[1]);
    return [parts1[0],parts2[0],parts2[1]];
}

function styleSelectionInline(style) {
    var sel = window.getSelection();
    var range = sel.getRangeAt(0);
    if(range.collapsed) {
        console.log("just change the state");
        return;
    }
    var info = saveSelection(editor);
    var mod = selectionToModelNode(info,model);
    var parts = splitThree(mod,info.startOffset,info.endOffset)
    wrapTextInInlineStyle(parts[1],style);
    syncDom(editor,model);
    restoreSelection(info);
}

function stopEvent(e) {
    e.preventDefault();
    e.stopPropagation();
}

document.getElementById('editor').addEventListener('keydown',function(e){
    if(e.metaKey===true && e.keyCode == 66) { //cmd-B
        stopEvent(e);
        styleSelectionInline('bold');
    }
    if(e.metaKey===true && e.keyCode == 73) { //cmd-I
        stopEvent(e);
        styleSelectionInline('italic');
    }
    if(e.metaKey===true && e.keyCode == 67 && e.shiftKey) { //cmd-shift-C
        stopEvent(e);
        styleSelectionInline('inline-code');
    }
});

function findParentBlockDom(elem) {
    var parent = elem.parentElement;
    if(parent.tagName == 'DIV') {
        return parent;
    }
    return null;
}
function findModelForDom(root,target) {
    for(var i=0; i<root.content.length; i++) {
        var node = root.content[i];
        if(node.id == target.id) {
            return node;
        }
        if(node.type == 'block' || node.type == 'inline') {
            var ans = findModelForDom(node,target);
            if(ans != null) return ans;
        }
    }
    return null;
}

function changeBlockStyle(style) {
    var sel = window.getSelection();
    var range = sel.getRangeAt(0);
    var block = findParentBlockDom(range.commonAncestorContainer);
    var mod_b = findModelForDom({content:model},block);
    mod_b.style = style;
    var ran = saveSelection(editor);
    syncDom(editor,model);
    restoreSelection(ran);
}
document.getElementById("header").addEventListener('click',function(e) {
    stopEvent(e);
    changeBlockStyle('header');
});
document.getElementById("body").addEventListener('click',function(e) {
    stopEvent(e);
    changeBlockStyle('body');
});
document.getElementById("block-code").addEventListener('click',function(e) {
    stopEvent(e);
    changeBlockStyle('block-code');
});
</script>
</html>
